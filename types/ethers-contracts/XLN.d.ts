/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  Contract,
  ContractTransaction,
  Overrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import { TypedEventFilter, TypedEvent, TypedListener } from "./commons";

interface XLNInterface extends ethers.utils.Interface {
  functions: {
    "assets(uint256)": FunctionFragment;
    "channels(bytes)": FunctionFragment;
    "hash_to_block(bytes32)": FunctionFragment;
    "hubs(uint256)": FunctionFragment;
    "log(string,bytes)": FunctionFragment;
    "registerAsset(tuple)": FunctionFragment;
    "registerHub(uint256,string)": FunctionFragment;
    "revealSecret(bytes32)": FunctionFragment;
    "cleanSecret(bytes32)": FunctionFragment;
    "tokenToReserve(tuple)": FunctionFragment;
    "reserveToToken(tuple)": FunctionFragment;
    "reserveToReserve(tuple)": FunctionFragment;
    "reserveToChannel(tuple)": FunctionFragment;
    "channelToReserve(tuple)": FunctionFragment;
    "cooperativeProof(tuple)": FunctionFragment;
    "disputeProof(tuple)": FunctionFragment;
    "revealEntries(tuple)": FunctionFragment;
    "getDebts(address,uint256)": FunctionFragment;
    "enforceDebts(address,uint256)": FunctionFragment;
    "processBatch(tuple)": FunctionFragment;
    "channelKey(address,address)": FunctionFragment;
    "getUser(address)": FunctionFragment;
    "getChannels(address,address[])": FunctionFragment;
    "getAllHubs()": FunctionFragment;
    "getAllAssets()": FunctionFragment;
    "topUp(address,uint256,uint256)": FunctionFragment;
    "createDebt(address,address,uint256,uint256)": FunctionFragment;
    "logChannel(address,address)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "assets",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "channels", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "hash_to_block",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "hubs", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "log",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "registerAsset",
    values: [{ name: string; addr: string }]
  ): string;
  encodeFunctionData(
    functionFragment: "registerHub",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "revealSecret",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "cleanSecret",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "tokenToReserve",
    values: [{ receiver: string; asset_id: BigNumberish; amount: BigNumberish }]
  ): string;
  encodeFunctionData(
    functionFragment: "reserveToToken",
    values: [{ receiver: string; asset_id: BigNumberish; amount: BigNumberish }]
  ): string;
  encodeFunctionData(
    functionFragment: "reserveToReserve",
    values: [{ receiver: string; asset_id: BigNumberish; amount: BigNumberish }]
  ): string;
  encodeFunctionData(
    functionFragment: "reserveToChannel",
    values: [
      {
        receiver: string;
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "channelToReserve",
    values: [
      {
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        sig: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cooperativeProof",
    values: [
      {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "disputeProof",
    values: [
      {
        partner: string;
        dispute_nonce: BigNumberish;
        entries_hash: BytesLike;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "revealEntries",
    values: [
      {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getDebts",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "enforceDebts",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "processBatch",
    values: [
      {
        cooperativeProof: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        disputeProof: {
          partner: string;
          dispute_nonce: BigNumberish;
          entries_hash: BytesLike;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        revealEntries: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
        }[];
        reserveToChannel: {
          receiver: string;
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        }[];
        channelToReserve: {
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
          sig: BytesLike;
        }[];
        reserveToToken: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        tokenToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        reserveToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        revealSecret: BytesLike[];
        cleanSecret: BytesLike[];
        hub_id: BigNumberish;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "channelKey",
    values: [string, string]
  ): string;
  encodeFunctionData(functionFragment: "getUser", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getChannels",
    values: [string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllHubs",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAllAssets",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "topUp",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "createDebt",
    values: [string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "logChannel",
    values: [string, string]
  ): string;

  decodeFunctionResult(functionFragment: "assets", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "channels", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "hash_to_block",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hubs", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "log", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "registerAsset",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerHub",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revealSecret",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cleanSecret",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenToReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reserveToToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reserveToReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reserveToChannel",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "channelToReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cooperativeProof",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disputeProof",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revealEntries",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getDebts", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "enforceDebts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "processBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "channelKey", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getUser", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getChannels",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getAllHubs", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getAllAssets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "topUp", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "createDebt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "logChannel", data: BytesLike): Result;

  events: {
    "LogAddress(string,address)": EventFragment;
    "LogBool(string,bool)": EventFragment;
    "LogBytes(string,bytes)": EventFragment;
    "LogBytes32(string,bytes32)": EventFragment;
    "LogInt(string,int256)": EventFragment;
    "LogString(string,string)": EventFragment;
    "LogUint(string,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "LogAddress"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogBool"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogBytes"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogBytes32"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogInt"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogString"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogUint"): EventFragment;
}

export class XLN extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: XLNInterface;

  functions: {
    assets(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, string] & { name: string; addr: string }>;

    "assets(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, string] & { name: string; addr: string }>;

    channels(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
        channel_counter: BigNumber;
        cooperative_nonce: BigNumber;
        dispute_nonce: BigNumber;
        dispute_started_by_left: boolean;
        dispute_until_block: BigNumber;
        entries_hash: string;
      }
    >;

    "channels(bytes)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
        channel_counter: BigNumber;
        cooperative_nonce: BigNumber;
        dispute_nonce: BigNumber;
        dispute_started_by_left: boolean;
        dispute_until_block: BigNumber;
        entries_hash: string;
      }
    >;

    hash_to_block(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "hash_to_block(bytes32)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    hubs(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, string] & {
        addr: string;
        gasused: BigNumber;
        uri: string;
      }
    >;

    "hubs(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, string] & {
        addr: string;
        gasused: BigNumber;
        uri: string;
      }
    >;

    "log(string,bytes)"(
      s: string,
      x: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "log(string,address)"(
      s: string,
      x: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "log(string,bytes32)"(
      s: string,
      x: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "log(string,int256)"(
      s: string,
      x: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "log(string,string)"(
      s: string,
      x: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "log(string,uint256)"(
      s: string,
      x: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "log(string,bool)"(
      s: string,
      x: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    registerAsset(
      assetToRegister: { name: string; addr: string },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "registerAsset((string,address))"(
      assetToRegister: { name: string; addr: string },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    registerHub(
      hub_id: BigNumberish,
      new_uri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "registerHub(uint256,string)"(
      hub_id: BigNumberish,
      new_uri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    revealSecret(
      secret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "revealSecret(bytes32)"(
      secret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cleanSecret(
      hash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "cleanSecret(bytes32)"(
      hash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    tokenToReserve(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "tokenToReserve((address,uint256,uint256))"(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    reserveToToken(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "reserveToToken((address,uint256,uint256))"(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    reserveToReserve(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "reserveToReserve((address,uint256,uint256))"(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    reserveToChannel(
      params: {
        receiver: string;
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "reserveToChannel((address,address,tuple[]))"(
      params: {
        receiver: string;
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    channelToReserve(
      params: {
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "channelToReserve((address,tuple[],bytes))"(
      params: {
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    cooperativeProof(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "cooperativeProof((address,tuple[],bytes))"(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    disputeProof(
      params: {
        partner: string;
        dispute_nonce: BigNumberish;
        entries_hash: BytesLike;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "disputeProof((address,uint256,bytes32,tuple[],bytes))"(
      params: {
        partner: string;
        dispute_nonce: BigNumberish;
        entries_hash: BytesLike;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    revealEntries(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "revealEntries((address,tuple[]))"(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getDebts(
      addr: string,
      asset_id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        ([BigNumber, string] & { amount: BigNumber; pay_to: string })[],
        BigNumber
      ] & {
        allDebts: ([BigNumber, string] & {
          amount: BigNumber;
          pay_to: string;
        })[];
        currentDebtIndex: BigNumber;
      }
    >;

    "getDebts(address,uint256)"(
      addr: string,
      asset_id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        ([BigNumber, string] & { amount: BigNumber; pay_to: string })[],
        BigNumber
      ] & {
        allDebts: ([BigNumber, string] & {
          amount: BigNumber;
          pay_to: string;
        })[];
        currentDebtIndex: BigNumber;
      }
    >;

    enforceDebts(
      addr: string,
      asset_id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "enforceDebts(address,uint256)"(
      addr: string,
      asset_id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    processBatch(
      b: {
        cooperativeProof: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        disputeProof: {
          partner: string;
          dispute_nonce: BigNumberish;
          entries_hash: BytesLike;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        revealEntries: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
        }[];
        reserveToChannel: {
          receiver: string;
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        }[];
        channelToReserve: {
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
          sig: BytesLike;
        }[];
        reserveToToken: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        tokenToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        reserveToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        revealSecret: BytesLike[];
        cleanSecret: BytesLike[];
        hub_id: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "processBatch((tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],bytes32[],bytes32[],uint256))"(
      b: {
        cooperativeProof: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        disputeProof: {
          partner: string;
          dispute_nonce: BigNumberish;
          entries_hash: BytesLike;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        revealEntries: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
        }[];
        reserveToChannel: {
          receiver: string;
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        }[];
        channelToReserve: {
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
          sig: BytesLike;
        }[];
        reserveToToken: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        tokenToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        reserveToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        revealSecret: BytesLike[];
        cleanSecret: BytesLike[];
        hub_id: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    channelKey(
      a1: string,
      a2: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    "channelKey(address,address)"(
      a1: string,
      a2: string,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getUser(
      addr: string,
      overrides?: CallOverrides
    ): Promise<
      [
        [
          BigNumber,
          ([
            BigNumber,
            BigNumber,
            ([BigNumber, string] & { amount: BigNumber; pay_to: string })[]
          ] & {
            reserve: BigNumber;
            debtIndex: BigNumber;
            debts: ([BigNumber, string] & {
              amount: BigNumber;
              pay_to: string;
            })[];
          })[]
        ] & {
          ETH_balance: BigNumber;
          assets: ([
            BigNumber,
            BigNumber,
            ([BigNumber, string] & { amount: BigNumber; pay_to: string })[]
          ] & {
            reserve: BigNumber;
            debtIndex: BigNumber;
            debts: ([BigNumber, string] & {
              amount: BigNumber;
              pay_to: string;
            })[];
          })[];
        }
      ]
    >;

    "getUser(address)"(
      addr: string,
      overrides?: CallOverrides
    ): Promise<
      [
        [
          BigNumber,
          ([
            BigNumber,
            BigNumber,
            ([BigNumber, string] & { amount: BigNumber; pay_to: string })[]
          ] & {
            reserve: BigNumber;
            debtIndex: BigNumber;
            debts: ([BigNumber, string] & {
              amount: BigNumber;
              pay_to: string;
            })[];
          })[]
        ] & {
          ETH_balance: BigNumber;
          assets: ([
            BigNumber,
            BigNumber,
            ([BigNumber, string] & { amount: BigNumber; pay_to: string })[]
          ] & {
            reserve: BigNumber;
            debtIndex: BigNumber;
            debts: ([BigNumber, string] & {
              amount: BigNumber;
              pay_to: string;
            })[];
          })[];
        }
      ]
    >;

    getChannels(
      addr: string,
      partners: string[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([
          string,
          [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
            channel_counter: BigNumber;
            cooperative_nonce: BigNumber;
            dispute_nonce: BigNumber;
            dispute_started_by_left: boolean;
            dispute_until_block: BigNumber;
            entries_hash: string;
          },
          ([BigNumber, BigNumber] & {
            collateral: BigNumber;
            ondelta: BigNumber;
          })[]
        ] & {
          partner: string;
          channel: [
            BigNumber,
            BigNumber,
            BigNumber,
            boolean,
            BigNumber,
            string
          ] & {
            channel_counter: BigNumber;
            cooperative_nonce: BigNumber;
            dispute_nonce: BigNumber;
            dispute_started_by_left: boolean;
            dispute_until_block: BigNumber;
            entries_hash: string;
          };
          collaterals: ([BigNumber, BigNumber] & {
            collateral: BigNumber;
            ondelta: BigNumber;
          })[];
        })[]
      ] & {
        response: ([
          string,
          [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
            channel_counter: BigNumber;
            cooperative_nonce: BigNumber;
            dispute_nonce: BigNumber;
            dispute_started_by_left: boolean;
            dispute_until_block: BigNumber;
            entries_hash: string;
          },
          ([BigNumber, BigNumber] & {
            collateral: BigNumber;
            ondelta: BigNumber;
          })[]
        ] & {
          partner: string;
          channel: [
            BigNumber,
            BigNumber,
            BigNumber,
            boolean,
            BigNumber,
            string
          ] & {
            channel_counter: BigNumber;
            cooperative_nonce: BigNumber;
            dispute_nonce: BigNumber;
            dispute_started_by_left: boolean;
            dispute_until_block: BigNumber;
            entries_hash: string;
          };
          collaterals: ([BigNumber, BigNumber] & {
            collateral: BigNumber;
            ondelta: BigNumber;
          })[];
        })[];
      }
    >;

    "getChannels(address,address[])"(
      addr: string,
      partners: string[],
      overrides?: CallOverrides
    ): Promise<
      [
        ([
          string,
          [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
            channel_counter: BigNumber;
            cooperative_nonce: BigNumber;
            dispute_nonce: BigNumber;
            dispute_started_by_left: boolean;
            dispute_until_block: BigNumber;
            entries_hash: string;
          },
          ([BigNumber, BigNumber] & {
            collateral: BigNumber;
            ondelta: BigNumber;
          })[]
        ] & {
          partner: string;
          channel: [
            BigNumber,
            BigNumber,
            BigNumber,
            boolean,
            BigNumber,
            string
          ] & {
            channel_counter: BigNumber;
            cooperative_nonce: BigNumber;
            dispute_nonce: BigNumber;
            dispute_started_by_left: boolean;
            dispute_until_block: BigNumber;
            entries_hash: string;
          };
          collaterals: ([BigNumber, BigNumber] & {
            collateral: BigNumber;
            ondelta: BigNumber;
          })[];
        })[]
      ] & {
        response: ([
          string,
          [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
            channel_counter: BigNumber;
            cooperative_nonce: BigNumber;
            dispute_nonce: BigNumber;
            dispute_started_by_left: boolean;
            dispute_until_block: BigNumber;
            entries_hash: string;
          },
          ([BigNumber, BigNumber] & {
            collateral: BigNumber;
            ondelta: BigNumber;
          })[]
        ] & {
          partner: string;
          channel: [
            BigNumber,
            BigNumber,
            BigNumber,
            boolean,
            BigNumber,
            string
          ] & {
            channel_counter: BigNumber;
            cooperative_nonce: BigNumber;
            dispute_nonce: BigNumber;
            dispute_started_by_left: boolean;
            dispute_until_block: BigNumber;
            entries_hash: string;
          };
          collaterals: ([BigNumber, BigNumber] & {
            collateral: BigNumber;
            ondelta: BigNumber;
          })[];
        })[];
      }
    >;

    getAllHubs(
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, BigNumber, string] & {
          addr: string;
          gasused: BigNumber;
          uri: string;
        })[]
      ]
    >;

    "getAllHubs()"(
      overrides?: CallOverrides
    ): Promise<
      [
        ([string, BigNumber, string] & {
          addr: string;
          gasused: BigNumber;
          uri: string;
        })[]
      ]
    >;

    getAllAssets(
      overrides?: CallOverrides
    ): Promise<[([string, string] & { name: string; addr: string })[]]>;

    "getAllAssets()"(
      overrides?: CallOverrides
    ): Promise<[([string, string] & { name: string; addr: string })[]]>;

    topUp(
      addr: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "topUp(address,uint256,uint256)"(
      addr: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    createDebt(
      addr: string,
      pay_to: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "createDebt(address,address,uint256,uint256)"(
      addr: string,
      pay_to: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    logChannel(
      a1: string,
      a2: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "logChannel(address,address)"(
      a1: string,
      a2: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  assets(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[string, string] & { name: string; addr: string }>;

  "assets(uint256)"(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<[string, string] & { name: string; addr: string }>;

  channels(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
      channel_counter: BigNumber;
      cooperative_nonce: BigNumber;
      dispute_nonce: BigNumber;
      dispute_started_by_left: boolean;
      dispute_until_block: BigNumber;
      entries_hash: string;
    }
  >;

  "channels(bytes)"(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
      channel_counter: BigNumber;
      cooperative_nonce: BigNumber;
      dispute_nonce: BigNumber;
      dispute_started_by_left: boolean;
      dispute_until_block: BigNumber;
      entries_hash: string;
    }
  >;

  hash_to_block(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

  "hash_to_block(bytes32)"(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  hubs(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber, string] & {
      addr: string;
      gasused: BigNumber;
      uri: string;
    }
  >;

  "hubs(uint256)"(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber, string] & {
      addr: string;
      gasused: BigNumber;
      uri: string;
    }
  >;

  "log(string,bytes)"(
    s: string,
    x: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "log(string,address)"(
    s: string,
    x: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "log(string,bytes32)"(
    s: string,
    x: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "log(string,int256)"(
    s: string,
    x: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "log(string,string)"(
    s: string,
    x: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "log(string,uint256)"(
    s: string,
    x: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "log(string,bool)"(
    s: string,
    x: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  registerAsset(
    assetToRegister: { name: string; addr: string },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "registerAsset((string,address))"(
    assetToRegister: { name: string; addr: string },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  registerHub(
    hub_id: BigNumberish,
    new_uri: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "registerHub(uint256,string)"(
    hub_id: BigNumberish,
    new_uri: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  revealSecret(
    secret: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "revealSecret(bytes32)"(
    secret: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  cleanSecret(
    hash: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "cleanSecret(bytes32)"(
    hash: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  tokenToReserve(
    params: { receiver: string; asset_id: BigNumberish; amount: BigNumberish },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "tokenToReserve((address,uint256,uint256))"(
    params: { receiver: string; asset_id: BigNumberish; amount: BigNumberish },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  reserveToToken(
    params: { receiver: string; asset_id: BigNumberish; amount: BigNumberish },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "reserveToToken((address,uint256,uint256))"(
    params: { receiver: string; asset_id: BigNumberish; amount: BigNumberish },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  reserveToReserve(
    params: { receiver: string; asset_id: BigNumberish; amount: BigNumberish },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "reserveToReserve((address,uint256,uint256))"(
    params: { receiver: string; asset_id: BigNumberish; amount: BigNumberish },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  reserveToChannel(
    params: {
      receiver: string;
      partner: string;
      pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "reserveToChannel((address,address,tuple[]))"(
    params: {
      receiver: string;
      partner: string;
      pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  channelToReserve(
    params: {
      partner: string;
      pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
      sig: BytesLike;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "channelToReserve((address,tuple[],bytes))"(
    params: {
      partner: string;
      pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
      sig: BytesLike;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  cooperativeProof(
    params: {
      partner: string;
      entries: {
        asset_id: BigNumberish;
        offdelta: BigNumberish;
        left_locks: {
          amount: BigNumberish;
          until_block: BigNumberish;
          hash: BytesLike;
        }[];
        right_locks: {
          amount: BigNumberish;
          until_block: BigNumberish;
          hash: BytesLike;
        }[];
      }[];
      sig: BytesLike;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "cooperativeProof((address,tuple[],bytes))"(
    params: {
      partner: string;
      entries: {
        asset_id: BigNumberish;
        offdelta: BigNumberish;
        left_locks: {
          amount: BigNumberish;
          until_block: BigNumberish;
          hash: BytesLike;
        }[];
        right_locks: {
          amount: BigNumberish;
          until_block: BigNumberish;
          hash: BytesLike;
        }[];
      }[];
      sig: BytesLike;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  disputeProof(
    params: {
      partner: string;
      dispute_nonce: BigNumberish;
      entries_hash: BytesLike;
      entries: {
        asset_id: BigNumberish;
        offdelta: BigNumberish;
        left_locks: {
          amount: BigNumberish;
          until_block: BigNumberish;
          hash: BytesLike;
        }[];
        right_locks: {
          amount: BigNumberish;
          until_block: BigNumberish;
          hash: BytesLike;
        }[];
      }[];
      sig: BytesLike;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "disputeProof((address,uint256,bytes32,tuple[],bytes))"(
    params: {
      partner: string;
      dispute_nonce: BigNumberish;
      entries_hash: BytesLike;
      entries: {
        asset_id: BigNumberish;
        offdelta: BigNumberish;
        left_locks: {
          amount: BigNumberish;
          until_block: BigNumberish;
          hash: BytesLike;
        }[];
        right_locks: {
          amount: BigNumberish;
          until_block: BigNumberish;
          hash: BytesLike;
        }[];
      }[];
      sig: BytesLike;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  revealEntries(
    params: {
      partner: string;
      entries: {
        asset_id: BigNumberish;
        offdelta: BigNumberish;
        left_locks: {
          amount: BigNumberish;
          until_block: BigNumberish;
          hash: BytesLike;
        }[];
        right_locks: {
          amount: BigNumberish;
          until_block: BigNumberish;
          hash: BytesLike;
        }[];
      }[];
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "revealEntries((address,tuple[]))"(
    params: {
      partner: string;
      entries: {
        asset_id: BigNumberish;
        offdelta: BigNumberish;
        left_locks: {
          amount: BigNumberish;
          until_block: BigNumberish;
          hash: BytesLike;
        }[];
        right_locks: {
          amount: BigNumberish;
          until_block: BigNumberish;
          hash: BytesLike;
        }[];
      }[];
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getDebts(
    addr: string,
    asset_id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      ([BigNumber, string] & { amount: BigNumber; pay_to: string })[],
      BigNumber
    ] & {
      allDebts: ([BigNumber, string] & { amount: BigNumber; pay_to: string })[];
      currentDebtIndex: BigNumber;
    }
  >;

  "getDebts(address,uint256)"(
    addr: string,
    asset_id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      ([BigNumber, string] & { amount: BigNumber; pay_to: string })[],
      BigNumber
    ] & {
      allDebts: ([BigNumber, string] & { amount: BigNumber; pay_to: string })[];
      currentDebtIndex: BigNumber;
    }
  >;

  enforceDebts(
    addr: string,
    asset_id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "enforceDebts(address,uint256)"(
    addr: string,
    asset_id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  processBatch(
    b: {
      cooperativeProof: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      }[];
      disputeProof: {
        partner: string;
        dispute_nonce: BigNumberish;
        entries_hash: BytesLike;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      }[];
      revealEntries: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
      }[];
      reserveToChannel: {
        receiver: string;
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
      }[];
      channelToReserve: {
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        sig: BytesLike;
      }[];
      reserveToToken: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      }[];
      tokenToReserve: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      }[];
      reserveToReserve: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      }[];
      revealSecret: BytesLike[];
      cleanSecret: BytesLike[];
      hub_id: BigNumberish;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "processBatch((tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],bytes32[],bytes32[],uint256))"(
    b: {
      cooperativeProof: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      }[];
      disputeProof: {
        partner: string;
        dispute_nonce: BigNumberish;
        entries_hash: BytesLike;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      }[];
      revealEntries: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
      }[];
      reserveToChannel: {
        receiver: string;
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
      }[];
      channelToReserve: {
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        sig: BytesLike;
      }[];
      reserveToToken: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      }[];
      tokenToReserve: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      }[];
      reserveToReserve: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      }[];
      revealSecret: BytesLike[];
      cleanSecret: BytesLike[];
      hub_id: BigNumberish;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  channelKey(
    a1: string,
    a2: string,
    overrides?: CallOverrides
  ): Promise<string>;

  "channelKey(address,address)"(
    a1: string,
    a2: string,
    overrides?: CallOverrides
  ): Promise<string>;

  getUser(
    addr: string,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      ([
        BigNumber,
        BigNumber,
        ([BigNumber, string] & { amount: BigNumber; pay_to: string })[]
      ] & {
        reserve: BigNumber;
        debtIndex: BigNumber;
        debts: ([BigNumber, string] & { amount: BigNumber; pay_to: string })[];
      })[]
    ] & {
      ETH_balance: BigNumber;
      assets: ([
        BigNumber,
        BigNumber,
        ([BigNumber, string] & { amount: BigNumber; pay_to: string })[]
      ] & {
        reserve: BigNumber;
        debtIndex: BigNumber;
        debts: ([BigNumber, string] & { amount: BigNumber; pay_to: string })[];
      })[];
    }
  >;

  "getUser(address)"(
    addr: string,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      ([
        BigNumber,
        BigNumber,
        ([BigNumber, string] & { amount: BigNumber; pay_to: string })[]
      ] & {
        reserve: BigNumber;
        debtIndex: BigNumber;
        debts: ([BigNumber, string] & { amount: BigNumber; pay_to: string })[];
      })[]
    ] & {
      ETH_balance: BigNumber;
      assets: ([
        BigNumber,
        BigNumber,
        ([BigNumber, string] & { amount: BigNumber; pay_to: string })[]
      ] & {
        reserve: BigNumber;
        debtIndex: BigNumber;
        debts: ([BigNumber, string] & { amount: BigNumber; pay_to: string })[];
      })[];
    }
  >;

  getChannels(
    addr: string,
    partners: string[],
    overrides?: CallOverrides
  ): Promise<
    ([
      string,
      [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
        channel_counter: BigNumber;
        cooperative_nonce: BigNumber;
        dispute_nonce: BigNumber;
        dispute_started_by_left: boolean;
        dispute_until_block: BigNumber;
        entries_hash: string;
      },
      ([BigNumber, BigNumber] & { collateral: BigNumber; ondelta: BigNumber })[]
    ] & {
      partner: string;
      channel: [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
        channel_counter: BigNumber;
        cooperative_nonce: BigNumber;
        dispute_nonce: BigNumber;
        dispute_started_by_left: boolean;
        dispute_until_block: BigNumber;
        entries_hash: string;
      };
      collaterals: ([BigNumber, BigNumber] & {
        collateral: BigNumber;
        ondelta: BigNumber;
      })[];
    })[]
  >;

  "getChannels(address,address[])"(
    addr: string,
    partners: string[],
    overrides?: CallOverrides
  ): Promise<
    ([
      string,
      [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
        channel_counter: BigNumber;
        cooperative_nonce: BigNumber;
        dispute_nonce: BigNumber;
        dispute_started_by_left: boolean;
        dispute_until_block: BigNumber;
        entries_hash: string;
      },
      ([BigNumber, BigNumber] & { collateral: BigNumber; ondelta: BigNumber })[]
    ] & {
      partner: string;
      channel: [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
        channel_counter: BigNumber;
        cooperative_nonce: BigNumber;
        dispute_nonce: BigNumber;
        dispute_started_by_left: boolean;
        dispute_until_block: BigNumber;
        entries_hash: string;
      };
      collaterals: ([BigNumber, BigNumber] & {
        collateral: BigNumber;
        ondelta: BigNumber;
      })[];
    })[]
  >;

  getAllHubs(
    overrides?: CallOverrides
  ): Promise<
    ([string, BigNumber, string] & {
      addr: string;
      gasused: BigNumber;
      uri: string;
    })[]
  >;

  "getAllHubs()"(
    overrides?: CallOverrides
  ): Promise<
    ([string, BigNumber, string] & {
      addr: string;
      gasused: BigNumber;
      uri: string;
    })[]
  >;

  getAllAssets(
    overrides?: CallOverrides
  ): Promise<([string, string] & { name: string; addr: string })[]>;

  "getAllAssets()"(
    overrides?: CallOverrides
  ): Promise<([string, string] & { name: string; addr: string })[]>;

  topUp(
    addr: string,
    asset_id: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "topUp(address,uint256,uint256)"(
    addr: string,
    asset_id: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  createDebt(
    addr: string,
    pay_to: string,
    asset_id: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "createDebt(address,address,uint256,uint256)"(
    addr: string,
    pay_to: string,
    asset_id: BigNumberish,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  logChannel(
    a1: string,
    a2: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "logChannel(address,address)"(
    a1: string,
    a2: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    assets(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, string] & { name: string; addr: string }>;

    "assets(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string, string] & { name: string; addr: string }>;

    channels(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
        channel_counter: BigNumber;
        cooperative_nonce: BigNumber;
        dispute_nonce: BigNumber;
        dispute_started_by_left: boolean;
        dispute_until_block: BigNumber;
        entries_hash: string;
      }
    >;

    "channels(bytes)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
        channel_counter: BigNumber;
        cooperative_nonce: BigNumber;
        dispute_nonce: BigNumber;
        dispute_started_by_left: boolean;
        dispute_until_block: BigNumber;
        entries_hash: string;
      }
    >;

    hash_to_block(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "hash_to_block(bytes32)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hubs(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, string] & {
        addr: string;
        gasused: BigNumber;
        uri: string;
      }
    >;

    "hubs(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, string] & {
        addr: string;
        gasused: BigNumber;
        uri: string;
      }
    >;

    "log(string,bytes)"(
      s: string,
      x: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "log(string,address)"(
      s: string,
      x: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "log(string,bytes32)"(
      s: string,
      x: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "log(string,int256)"(
      s: string,
      x: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "log(string,string)"(
      s: string,
      x: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "log(string,uint256)"(
      s: string,
      x: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "log(string,bool)"(
      s: string,
      x: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    registerAsset(
      assetToRegister: { name: string; addr: string },
      overrides?: CallOverrides
    ): Promise<void>;

    "registerAsset((string,address))"(
      assetToRegister: { name: string; addr: string },
      overrides?: CallOverrides
    ): Promise<void>;

    registerHub(
      hub_id: BigNumberish,
      new_uri: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "registerHub(uint256,string)"(
      hub_id: BigNumberish,
      new_uri: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    revealSecret(secret: BytesLike, overrides?: CallOverrides): Promise<void>;

    "revealSecret(bytes32)"(
      secret: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    cleanSecret(hash: BytesLike, overrides?: CallOverrides): Promise<void>;

    "cleanSecret(bytes32)"(
      hash: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    tokenToReserve(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    "tokenToReserve((address,uint256,uint256))"(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    reserveToToken(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    "reserveToToken((address,uint256,uint256))"(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    reserveToReserve(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    "reserveToReserve((address,uint256,uint256))"(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    reserveToChannel(
      params: {
        receiver: string;
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    "reserveToChannel((address,address,tuple[]))"(
      params: {
        receiver: string;
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    channelToReserve(
      params: {
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        sig: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    "channelToReserve((address,tuple[],bytes))"(
      params: {
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        sig: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    cooperativeProof(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    "cooperativeProof((address,tuple[],bytes))"(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    disputeProof(
      params: {
        partner: string;
        dispute_nonce: BigNumberish;
        entries_hash: BytesLike;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    "disputeProof((address,uint256,bytes32,tuple[],bytes))"(
      params: {
        partner: string;
        dispute_nonce: BigNumberish;
        entries_hash: BytesLike;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    revealEntries(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    "revealEntries((address,tuple[]))"(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    getDebts(
      addr: string,
      asset_id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        ([BigNumber, string] & { amount: BigNumber; pay_to: string })[],
        BigNumber
      ] & {
        allDebts: ([BigNumber, string] & {
          amount: BigNumber;
          pay_to: string;
        })[];
        currentDebtIndex: BigNumber;
      }
    >;

    "getDebts(address,uint256)"(
      addr: string,
      asset_id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        ([BigNumber, string] & { amount: BigNumber; pay_to: string })[],
        BigNumber
      ] & {
        allDebts: ([BigNumber, string] & {
          amount: BigNumber;
          pay_to: string;
        })[];
        currentDebtIndex: BigNumber;
      }
    >;

    enforceDebts(
      addr: string,
      asset_id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "enforceDebts(address,uint256)"(
      addr: string,
      asset_id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    processBatch(
      b: {
        cooperativeProof: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        disputeProof: {
          partner: string;
          dispute_nonce: BigNumberish;
          entries_hash: BytesLike;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        revealEntries: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
        }[];
        reserveToChannel: {
          receiver: string;
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        }[];
        channelToReserve: {
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
          sig: BytesLike;
        }[];
        reserveToToken: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        tokenToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        reserveToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        revealSecret: BytesLike[];
        cleanSecret: BytesLike[];
        hub_id: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    "processBatch((tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],bytes32[],bytes32[],uint256))"(
      b: {
        cooperativeProof: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        disputeProof: {
          partner: string;
          dispute_nonce: BigNumberish;
          entries_hash: BytesLike;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        revealEntries: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
        }[];
        reserveToChannel: {
          receiver: string;
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        }[];
        channelToReserve: {
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
          sig: BytesLike;
        }[];
        reserveToToken: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        tokenToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        reserveToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        revealSecret: BytesLike[];
        cleanSecret: BytesLike[];
        hub_id: BigNumberish;
      },
      overrides?: CallOverrides
    ): Promise<boolean>;

    channelKey(
      a1: string,
      a2: string,
      overrides?: CallOverrides
    ): Promise<string>;

    "channelKey(address,address)"(
      a1: string,
      a2: string,
      overrides?: CallOverrides
    ): Promise<string>;

    getUser(
      addr: string,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        ([
          BigNumber,
          BigNumber,
          ([BigNumber, string] & { amount: BigNumber; pay_to: string })[]
        ] & {
          reserve: BigNumber;
          debtIndex: BigNumber;
          debts: ([BigNumber, string] & {
            amount: BigNumber;
            pay_to: string;
          })[];
        })[]
      ] & {
        ETH_balance: BigNumber;
        assets: ([
          BigNumber,
          BigNumber,
          ([BigNumber, string] & { amount: BigNumber; pay_to: string })[]
        ] & {
          reserve: BigNumber;
          debtIndex: BigNumber;
          debts: ([BigNumber, string] & {
            amount: BigNumber;
            pay_to: string;
          })[];
        })[];
      }
    >;

    "getUser(address)"(
      addr: string,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        ([
          BigNumber,
          BigNumber,
          ([BigNumber, string] & { amount: BigNumber; pay_to: string })[]
        ] & {
          reserve: BigNumber;
          debtIndex: BigNumber;
          debts: ([BigNumber, string] & {
            amount: BigNumber;
            pay_to: string;
          })[];
        })[]
      ] & {
        ETH_balance: BigNumber;
        assets: ([
          BigNumber,
          BigNumber,
          ([BigNumber, string] & { amount: BigNumber; pay_to: string })[]
        ] & {
          reserve: BigNumber;
          debtIndex: BigNumber;
          debts: ([BigNumber, string] & {
            amount: BigNumber;
            pay_to: string;
          })[];
        })[];
      }
    >;

    getChannels(
      addr: string,
      partners: string[],
      overrides?: CallOverrides
    ): Promise<
      ([
        string,
        [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
          channel_counter: BigNumber;
          cooperative_nonce: BigNumber;
          dispute_nonce: BigNumber;
          dispute_started_by_left: boolean;
          dispute_until_block: BigNumber;
          entries_hash: string;
        },
        ([BigNumber, BigNumber] & {
          collateral: BigNumber;
          ondelta: BigNumber;
        })[]
      ] & {
        partner: string;
        channel: [
          BigNumber,
          BigNumber,
          BigNumber,
          boolean,
          BigNumber,
          string
        ] & {
          channel_counter: BigNumber;
          cooperative_nonce: BigNumber;
          dispute_nonce: BigNumber;
          dispute_started_by_left: boolean;
          dispute_until_block: BigNumber;
          entries_hash: string;
        };
        collaterals: ([BigNumber, BigNumber] & {
          collateral: BigNumber;
          ondelta: BigNumber;
        })[];
      })[]
    >;

    "getChannels(address,address[])"(
      addr: string,
      partners: string[],
      overrides?: CallOverrides
    ): Promise<
      ([
        string,
        [BigNumber, BigNumber, BigNumber, boolean, BigNumber, string] & {
          channel_counter: BigNumber;
          cooperative_nonce: BigNumber;
          dispute_nonce: BigNumber;
          dispute_started_by_left: boolean;
          dispute_until_block: BigNumber;
          entries_hash: string;
        },
        ([BigNumber, BigNumber] & {
          collateral: BigNumber;
          ondelta: BigNumber;
        })[]
      ] & {
        partner: string;
        channel: [
          BigNumber,
          BigNumber,
          BigNumber,
          boolean,
          BigNumber,
          string
        ] & {
          channel_counter: BigNumber;
          cooperative_nonce: BigNumber;
          dispute_nonce: BigNumber;
          dispute_started_by_left: boolean;
          dispute_until_block: BigNumber;
          entries_hash: string;
        };
        collaterals: ([BigNumber, BigNumber] & {
          collateral: BigNumber;
          ondelta: BigNumber;
        })[];
      })[]
    >;

    getAllHubs(
      overrides?: CallOverrides
    ): Promise<
      ([string, BigNumber, string] & {
        addr: string;
        gasused: BigNumber;
        uri: string;
      })[]
    >;

    "getAllHubs()"(
      overrides?: CallOverrides
    ): Promise<
      ([string, BigNumber, string] & {
        addr: string;
        gasused: BigNumber;
        uri: string;
      })[]
    >;

    getAllAssets(
      overrides?: CallOverrides
    ): Promise<([string, string] & { name: string; addr: string })[]>;

    "getAllAssets()"(
      overrides?: CallOverrides
    ): Promise<([string, string] & { name: string; addr: string })[]>;

    topUp(
      addr: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "topUp(address,uint256,uint256)"(
      addr: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    createDebt(
      addr: string,
      pay_to: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "createDebt(address,address,uint256,uint256)"(
      addr: string,
      pay_to: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    logChannel(
      a1: string,
      a2: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "logChannel(address,address)"(
      a1: string,
      a2: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    LogAddress(
      undefined: null,
      undefined: null
    ): TypedEventFilter<[string, string], { arg0: string; arg1: string }>;

    LogBool(
      undefined: null,
      undefined: null
    ): TypedEventFilter<[string, boolean], { arg0: string; arg1: boolean }>;

    LogBytes(
      undefined: null,
      undefined: null
    ): TypedEventFilter<[string, string], { arg0: string; arg1: string }>;

    LogBytes32(
      undefined: null,
      undefined: null
    ): TypedEventFilter<[string, string], { arg0: string; arg1: string }>;

    LogInt(
      undefined: null,
      undefined: null
    ): TypedEventFilter<[string, BigNumber], { arg0: string; arg1: BigNumber }>;

    LogString(
      undefined: null,
      undefined: null
    ): TypedEventFilter<[string, string], { arg0: string; arg1: string }>;

    LogUint(
      undefined: null,
      undefined: null
    ): TypedEventFilter<[string, BigNumber], { arg0: string; arg1: BigNumber }>;
  };

  estimateGas: {
    assets(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    "assets(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    channels(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    "channels(bytes)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hash_to_block(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "hash_to_block(bytes32)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hubs(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    "hubs(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "log(string,bytes)"(
      s: string,
      x: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "log(string,address)"(
      s: string,
      x: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "log(string,bytes32)"(
      s: string,
      x: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "log(string,int256)"(
      s: string,
      x: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "log(string,string)"(
      s: string,
      x: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "log(string,uint256)"(
      s: string,
      x: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "log(string,bool)"(
      s: string,
      x: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    registerAsset(
      assetToRegister: { name: string; addr: string },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "registerAsset((string,address))"(
      assetToRegister: { name: string; addr: string },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    registerHub(
      hub_id: BigNumberish,
      new_uri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "registerHub(uint256,string)"(
      hub_id: BigNumberish,
      new_uri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    revealSecret(
      secret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "revealSecret(bytes32)"(
      secret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    cleanSecret(
      hash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "cleanSecret(bytes32)"(
      hash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    tokenToReserve(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "tokenToReserve((address,uint256,uint256))"(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    reserveToToken(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "reserveToToken((address,uint256,uint256))"(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    reserveToReserve(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "reserveToReserve((address,uint256,uint256))"(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    reserveToChannel(
      params: {
        receiver: string;
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "reserveToChannel((address,address,tuple[]))"(
      params: {
        receiver: string;
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    channelToReserve(
      params: {
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "channelToReserve((address,tuple[],bytes))"(
      params: {
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    cooperativeProof(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "cooperativeProof((address,tuple[],bytes))"(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    disputeProof(
      params: {
        partner: string;
        dispute_nonce: BigNumberish;
        entries_hash: BytesLike;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "disputeProof((address,uint256,bytes32,tuple[],bytes))"(
      params: {
        partner: string;
        dispute_nonce: BigNumberish;
        entries_hash: BytesLike;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    revealEntries(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "revealEntries((address,tuple[]))"(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getDebts(
      addr: string,
      asset_id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getDebts(address,uint256)"(
      addr: string,
      asset_id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    enforceDebts(
      addr: string,
      asset_id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "enforceDebts(address,uint256)"(
      addr: string,
      asset_id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    processBatch(
      b: {
        cooperativeProof: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        disputeProof: {
          partner: string;
          dispute_nonce: BigNumberish;
          entries_hash: BytesLike;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        revealEntries: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
        }[];
        reserveToChannel: {
          receiver: string;
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        }[];
        channelToReserve: {
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
          sig: BytesLike;
        }[];
        reserveToToken: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        tokenToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        reserveToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        revealSecret: BytesLike[];
        cleanSecret: BytesLike[];
        hub_id: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "processBatch((tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],bytes32[],bytes32[],uint256))"(
      b: {
        cooperativeProof: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        disputeProof: {
          partner: string;
          dispute_nonce: BigNumberish;
          entries_hash: BytesLike;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        revealEntries: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
        }[];
        reserveToChannel: {
          receiver: string;
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        }[];
        channelToReserve: {
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
          sig: BytesLike;
        }[];
        reserveToToken: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        tokenToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        reserveToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        revealSecret: BytesLike[];
        cleanSecret: BytesLike[];
        hub_id: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    channelKey(
      a1: string,
      a2: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "channelKey(address,address)"(
      a1: string,
      a2: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUser(addr: string, overrides?: CallOverrides): Promise<BigNumber>;

    "getUser(address)"(
      addr: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getChannels(
      addr: string,
      partners: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "getChannels(address,address[])"(
      addr: string,
      partners: string[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAllHubs(overrides?: CallOverrides): Promise<BigNumber>;

    "getAllHubs()"(overrides?: CallOverrides): Promise<BigNumber>;

    getAllAssets(overrides?: CallOverrides): Promise<BigNumber>;

    "getAllAssets()"(overrides?: CallOverrides): Promise<BigNumber>;

    topUp(
      addr: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "topUp(address,uint256,uint256)"(
      addr: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    createDebt(
      addr: string,
      pay_to: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "createDebt(address,address,uint256,uint256)"(
      addr: string,
      pay_to: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    logChannel(
      a1: string,
      a2: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "logChannel(address,address)"(
      a1: string,
      a2: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    assets(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "assets(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    channels(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "channels(bytes)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hash_to_block(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "hash_to_block(bytes32)"(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hubs(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "hubs(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "log(string,bytes)"(
      s: string,
      x: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "log(string,address)"(
      s: string,
      x: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "log(string,bytes32)"(
      s: string,
      x: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "log(string,int256)"(
      s: string,
      x: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "log(string,string)"(
      s: string,
      x: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "log(string,uint256)"(
      s: string,
      x: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "log(string,bool)"(
      s: string,
      x: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    registerAsset(
      assetToRegister: { name: string; addr: string },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "registerAsset((string,address))"(
      assetToRegister: { name: string; addr: string },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    registerHub(
      hub_id: BigNumberish,
      new_uri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "registerHub(uint256,string)"(
      hub_id: BigNumberish,
      new_uri: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    revealSecret(
      secret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "revealSecret(bytes32)"(
      secret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    cleanSecret(
      hash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "cleanSecret(bytes32)"(
      hash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    tokenToReserve(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "tokenToReserve((address,uint256,uint256))"(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    reserveToToken(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "reserveToToken((address,uint256,uint256))"(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    reserveToReserve(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "reserveToReserve((address,uint256,uint256))"(
      params: {
        receiver: string;
        asset_id: BigNumberish;
        amount: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    reserveToChannel(
      params: {
        receiver: string;
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "reserveToChannel((address,address,tuple[]))"(
      params: {
        receiver: string;
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    channelToReserve(
      params: {
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "channelToReserve((address,tuple[],bytes))"(
      params: {
        partner: string;
        pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    cooperativeProof(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "cooperativeProof((address,tuple[],bytes))"(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    disputeProof(
      params: {
        partner: string;
        dispute_nonce: BigNumberish;
        entries_hash: BytesLike;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "disputeProof((address,uint256,bytes32,tuple[],bytes))"(
      params: {
        partner: string;
        dispute_nonce: BigNumberish;
        entries_hash: BytesLike;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
        sig: BytesLike;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    revealEntries(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "revealEntries((address,tuple[]))"(
      params: {
        partner: string;
        entries: {
          asset_id: BigNumberish;
          offdelta: BigNumberish;
          left_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
          right_locks: {
            amount: BigNumberish;
            until_block: BigNumberish;
            hash: BytesLike;
          }[];
        }[];
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getDebts(
      addr: string,
      asset_id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getDebts(address,uint256)"(
      addr: string,
      asset_id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    enforceDebts(
      addr: string,
      asset_id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "enforceDebts(address,uint256)"(
      addr: string,
      asset_id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    processBatch(
      b: {
        cooperativeProof: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        disputeProof: {
          partner: string;
          dispute_nonce: BigNumberish;
          entries_hash: BytesLike;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        revealEntries: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
        }[];
        reserveToChannel: {
          receiver: string;
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        }[];
        channelToReserve: {
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
          sig: BytesLike;
        }[];
        reserveToToken: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        tokenToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        reserveToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        revealSecret: BytesLike[];
        cleanSecret: BytesLike[];
        hub_id: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "processBatch((tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],tuple[],bytes32[],bytes32[],uint256))"(
      b: {
        cooperativeProof: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        disputeProof: {
          partner: string;
          dispute_nonce: BigNumberish;
          entries_hash: BytesLike;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
          sig: BytesLike;
        }[];
        revealEntries: {
          partner: string;
          entries: {
            asset_id: BigNumberish;
            offdelta: BigNumberish;
            left_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
            right_locks: {
              amount: BigNumberish;
              until_block: BigNumberish;
              hash: BytesLike;
            }[];
          }[];
        }[];
        reserveToChannel: {
          receiver: string;
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
        }[];
        channelToReserve: {
          partner: string;
          pairs: { asset_id: BigNumberish; amount: BigNumberish }[];
          sig: BytesLike;
        }[];
        reserveToToken: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        tokenToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        reserveToReserve: {
          receiver: string;
          asset_id: BigNumberish;
          amount: BigNumberish;
        }[];
        revealSecret: BytesLike[];
        cleanSecret: BytesLike[];
        hub_id: BigNumberish;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    channelKey(
      a1: string,
      a2: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "channelKey(address,address)"(
      a1: string,
      a2: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUser(
      addr: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getUser(address)"(
      addr: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getChannels(
      addr: string,
      partners: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "getChannels(address,address[])"(
      addr: string,
      partners: string[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAllHubs(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "getAllHubs()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getAllAssets(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "getAllAssets()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    topUp(
      addr: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "topUp(address,uint256,uint256)"(
      addr: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    createDebt(
      addr: string,
      pay_to: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "createDebt(address,address,uint256,uint256)"(
      addr: string,
      pay_to: string,
      asset_id: BigNumberish,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    logChannel(
      a1: string,
      a2: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "logChannel(address,address)"(
      a1: string,
      a2: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
